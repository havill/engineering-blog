<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Manish Yadav on Rakuten Engineering Blog</title><link>https://engineering.rakuten.today/authors/manish-yadav/</link><description>Recent content in Manish Yadav on Rakuten Engineering Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 18 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://engineering.rakuten.today/authors/manish-yadav/index.xml" rel="self" type="application/rss+xml"/><item><title>Zero-Downtime Rolling Deployments in Kubernetes</title><link>https://engineering.rakuten.today/post/graceful-k8s-delpoyments/</link><pubDate>Sun, 18 Jul 2021 00:00:00 +0000</pubDate><guid>https://engineering.rakuten.today/post/graceful-k8s-delpoyments/</guid><description>Photo by Kammeran Gonzalez-Keola used under Pexels License
At Rakuten, we generally use Kubernetes to run our services. Kubernetes enables us to operate robust systems at scale. However, Kubernetes is not perfect and in edge cases it may behave in unexpected ways. For example, during rolling deployments we expect no request failures &amp;mdash; a reasonable expectation, right? But when we ran functional tests during a deployment we noticed some requests failing &amp;mdash; to our surprise.</description></item></channel></rss>